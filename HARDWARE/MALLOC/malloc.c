#include "malloc.h"

/*********************************************************************************
			  ___   _     _____  _____  _   _  _____  _____  _   __
			 / _ \ | |   |_   _||  ___|| \ | ||_   _||  ___|| | / /
			/ /_\ \| |     | |  | |__  |  \| |  | |  | |__  | |/ /
			|  _  || |     | |  |  __| | . ` |  | |  |  __| |    \
			| | | || |_____| |_ | |___ | |\  |  | |  | |___ | |\  \
			\_| |_/\_____/\___/ \____/ \_| \_/  \_/  \____/ \_| \_/

 *	******************************************************************************
 *	本程序只供学习使用，未经作者许可，不得用于其它任何用途
 *	ALIENTEK Pandora STM32L475 IOT开发板
 *	内存管理代码
 *	正点原子@ALIENTEK
 *	技术论坛:www.openedv.com
 *	创建日期:2018/10/27
 *	版本：V1.0
 *	版权所有，盗版必究。
 *	Copyright(C) 广州市星翼电子科技有限公司 2014-2024
 *	All rights reserved
 *	******************************************************************************
 *	初始版本
 *	******************************************************************************/


//内存池(32字节对齐)
__align(32) u8 mem1base[MEM1_MAX_SIZE];													//内部SRAM1内存池
__align(32) u8 mem2base[MEM2_MAX_SIZE] __attribute__((at(0X10000000)));					//内部SRAM2内存池
//内存管理表
u32 mem1mapbase[MEM1_ALLOC_TABLE_SIZE];													//内部SRAM1内存池MAP
u32 mem2mapbase[MEM2_ALLOC_TABLE_SIZE] __attribute__((at(0X10000000 + MEM2_MAX_SIZE)));	//内部SRAM2内存池MAP
//内存管理参数
const u32 memtblsize[SRAMBANK] = {MEM1_ALLOC_TABLE_SIZE, MEM2_ALLOC_TABLE_SIZE};			//内存表大小
const u32 memblksize[SRAMBANK] = {MEM1_BLOCK_SIZE, MEM2_BLOCK_SIZE};						//内存分块大小
const u32 memsize[SRAMBANK] = {MEM1_MAX_SIZE, MEM2_MAX_SIZE};								//内存总大小

//内存管理控制器
struct _m_mallco_dev mallco_dev =
{
    my_mem_init,						//内存初始化
    my_mem_perused,						//内存使用率
    mem1base, mem2base,			//内存池
    mem1mapbase, mem2mapbase, //内存管理状态表
    0, 0,  		 					//内存管理未就绪
};

/**
 * @brief	复制内存
 *
 * @param   *des	目的地址
 * @param   *stc	源地址
 * @param   n		需要复制的内存长度(字节为单位)
 *
 * @return  void
 */
void mymemcpy(void *des, void *src, u32 n)
{
    u8 *xdes = des;
    u8 *xsrc = src;

    while(n--)*xdes++ = *xsrc++;
}

/**
 * @brief	设置内存
 *
 * @param   *s		内存首地址
 * @param   c		要设置的值
 * @param   count	需要设置的内存大小(字节为单位)
 *
 * @return  void
 */
void mymemset(void *s, u8 c, u32 count)
{
    u8 *xs = s;

    while(count--)*xs++ = c;
}

/**
 * @brief	内存管理初始化
 *
 * @param   memx	所属内存块
 *
 * @return  void
 */
void my_mem_init(u8 memx)
{
    mymemset(mallco_dev.memmap[memx], 0, memtblsize[memx] * 4);	//内存状态表数据清零
    mallco_dev.memrdy[memx] = 1;								//内存管理初始化OK
}

/**
 * @brief	获取内存使用率
 *
 * @param   memx	所属内存块
 *
 * @return  u16		使用率(扩大了10倍,0~1000,代表0.0%~100.0%)
 */
u16 my_mem_perused(u8 memx)
{
    u32 used = 0;
    u32 i;

    for(i = 0; i < memtblsize[memx]; i++)
    {
        if(mallco_dev.memmap[memx][i])used++;
    }

    return (used * 1000) / (memtblsize[memx]);
}

/**
 * @brief	内存分配(内部调用)
 *
 * @param   memx	所属内存块
 * @param   size	要分配的内存大小(字节)
 *
 * @return  u32		0XFFFFFFFF,代表错误;其他,内存偏移地址
 */
u32 my_mem_malloc(u8 memx, u32 size)
{
    signed long offset = 0;
    u32 nmemb;	//需要的内存块数
    u32 cmemb = 0; //连续空内存块数
    u32 i;

    if(!mallco_dev.memrdy[memx])mallco_dev.init(memx);//未初始化,先执行初始化

    if(size == 0)return 0XFFFFFFFF; //不需要分配

    nmemb = size / memblksize[memx];  	//获取需要分配的连续内存块数

    if(size % memblksize[memx])nmemb++;

    for(offset = memtblsize[memx] - 1; offset >= 0; offset--) //搜索整个内存控制区
    {
        if(!mallco_dev.memmap[memx][offset])cmemb++;//连续空内存块数增加

        else cmemb = 0;								//连续内存块清零

        if(cmemb == nmemb)							//找到了连续nmemb个空内存块
        {
            for(i = 0; i < nmemb; i++)  					//标注内存块非空
            {
                mallco_dev.memmap[memx][offset + i] = nmemb;
            }

            return (offset * memblksize[memx]); //返回偏移地址
        }
    }

    return 0XFFFFFFFF;//未找到符合分配条件的内存块
}

/**
 * @brief	释放内存(内部调用)
 *
 * @param   memx	所属内存块
 * @param   offset	内存地址偏移
 *
 * @return  u8		0,释放成功;1,释放失败;
 */
u8 my_mem_free(u8 memx, u32 offset)
{
    int i;

    if(!mallco_dev.memrdy[memx])//未初始化,先执行初始化
    {
        mallco_dev.init(memx);
        return 1;//未初始化
    }

    if(offset < memsize[memx]) //偏移在内存池内.
    {
        int index = offset / memblksize[memx];			//偏移所在内存块号码
        int nmemb = mallco_dev.memmap[memx][index];	//内存块数量

        for(i = 0; i < nmemb; i++)  						//内存块清零
        {
            mallco_dev.memmap[memx][index + i] = 0;
        }

        return 0;
    }

    else return 2; //偏移超区了.
}

/**
 * @brief	释放内存(外部调用)
 *
 * @param   memx	所属内存块
 * @param   ptr		内存首地址
 *
 * @return  void
 */
void myfree(u8 memx, void *ptr)
{
    u32 offset;

    if(ptr == NULL)return; //地址为0.

    offset = (u32)ptr - (u32)mallco_dev.membase[memx];
    my_mem_free(memx, offset);	//释放内存
}

/**
 * @brief	分配内存(外部调用)
 *
 * @param   memx	所属内存块
 * @param   size	内存大小(字节)
 *
 * @return  void*	分配到的内存首地址
 */
void *mymalloc(u8 memx, u32 size)
{
    u32 offset;
    offset = my_mem_malloc(memx, size);

    if(offset == 0XFFFFFFFF)return NULL;

    else return (void*)((u32)mallco_dev.membase[memx] + offset);
}

/**
 * @brief	重新分配内存(外部调用)
 *
 * @param   memx	所属内存块
 * @param   *ptr	旧内存首地址
 * @param   size	要分配的内存大小(字节)
 *
 * @return  void*	新分配到的内存首地址
 */
void *myrealloc(u8 memx, void *ptr, u32 size)
{
    u32 offset;
    offset = my_mem_malloc(memx, size);

    if(offset == 0XFFFFFFFF)return NULL;

    else
    {
        mymemcpy((void*)((u32)mallco_dev.membase[memx] + offset), ptr, size);	//拷贝旧内存内容到新内存
        myfree(memx, ptr);  											  		//释放旧内存
        return (void*)((u32)mallco_dev.membase[memx] + offset);  				//返回新内存首地址
    }
}












